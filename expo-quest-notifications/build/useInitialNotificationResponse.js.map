{"version":3,"file":"useInitialNotificationResponse.js","sourceRoot":"","sources":["../src/useInitialNotificationResponse.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAC;AAC5C,OAAO,EAAE,QAAQ,EAAE,MAAM,cAAc,CAAC;AAGxC,OAAO,EAAE,uCAAuC,EAAE,MAAM,wBAAwB,CAAC;AAEjF,yDAAyD;AACzD,8DAA8D;AAC9D,sDAAsD;AACtD,wDAAwD;AACxD,EAAE;AACF,mDAAmD;AACnD,kDAAkD;AAClD,oDAAoD;AACpD,kDAAkD;AAClD,gDAAgD;AAChD,yDAAyD;AACzD,6DAA6D;AAC7D,+BAA+B;AAE/B,uCAAuC;AACvC,qBAAqB;AACrB,uFAAuF;AACvF,wEAAwE;AACxE,uDAAuD;AACvD,0DAA0D;AAC1D,IAAI,iCAAiC,GAA4C,SAAS,CAAC;AAE3F,iEAAiE;AACjE,IAAI,uCAAuC,GAAwB,uCAAuC,CACxG,QAAQ,CAAC,EAAE;IACT,mBAAmB;IACnB,iCAAiC,GAAG,QAAQ,CAAC;AAC/C,CAAC,CACF,CAAC;AAEF,SAAS,kCAAkC;IACzC,8CAA8C;IAC9C,UAAU,CAAC,GAAG,EAAE;QACd,iDAAiD;QACjD,mCAAmC;QACnC,2BAA2B;QAC3B,iCAAiC,GAAG,iCAAiC,IAAI,IAAI,CAAC;QAC9E,2CAA2C;QAC3C,IAAI,uCAAuC,EAAE;YAC3C,uCAAuC,CAAC,MAAM,EAAE,CAAC;YACjD,uCAAuC,GAAG,IAAI,CAAC;SAChD;QACD,iDAAiD;QACjD,QAAQ,CAAC,mBAAmB,CAAC,QAAQ,EAAE,kCAAkC,CAAC,CAAC;IAC7E,CAAC,EAAE,CAAC,CAAC,CAAC;AACR,CAAC;AAED,QAAQ,CAAC,gBAAgB,CAAC,QAAQ,EAAE,kCAAkC,CAAC,CAAC;AAExE;;;;;;GAMG;AACH,MAAM,CAAC,OAAO,UAAU,8BAA8B;IACpD,MAAM,CAAC,2BAA2B,EAAE,8BAA8B,CAAC,GAAG,QAAQ,CAE5E,iCAAiC,CAAC,CAAC;IAErC,SAAS,CAAC,GAAG,EAAE;QACb,gDAAgD;QAChD,qEAAqE;QACrE,MAAM,SAAS,GAAG,UAAU,CAAC,GAAG,EAAE;YAChC,qDAAqD;YACrD,sEAAsE;YACtE,8BAA8B,CAC5B,eAAe,CAAC,EAAE,CAAC,eAAe,IAAI,iCAAiC,IAAI,IAAI,CAChF,CAAC;QACJ,CAAC,EAAE,CAAC,CAAC,CAAC;QAEN,OAAO,GAAG,EAAE;YACV,YAAY,CAAC,SAAS,CAAC,CAAC;QAC1B,CAAC,CAAC;IACJ,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,OAAO,2BAA2B,CAAC;AACrC,CAAC","sourcesContent":["import { Subscription } from '@unimodules/core';\nimport { useEffect, useState } from 'react';\nimport { AppState } from 'react-native';\n\nimport { NotificationResponse } from './Notifications.types';\nimport { addNotificationResponseReceivedListener } from './NotificationsEmitter';\n\n// We know that the initial notification response happens\n// between registering the listener in global scope of the app\n// and execution of setTimeout(0)-d callback scheduled\n// inside a \"change to active\" app state event listener.\n//\n// An approach that is simple enough and works well\n// is to update the global value as soon as we get\n// any notification response, but only if it happens\n// early enough that we consider this an \"initial\"\n// notification response. To ensure we don't use\n// later responses as \"initial\" we clear the subscription\n// as soon as we know that if there was an \"initial\" response\n// it has already been emitted.\n\n// Initial notification response holder\n// The value changes:\n//   `undefined` -> `NotificationResponse` if there is an initial notification response\n//   `undefined` -> `null` if there was no initial notification response\n// The first change happens inside the global listener,\n// the second one in `dispatchSetInitialResponseAndClear`.\nlet globalInitialNotificationResponse: NotificationResponse | undefined | null = undefined;\n\n// A subscription waiting for initial notification response event\nlet initialNotificationResponseSubscription: Subscription | null = addNotificationResponseReceivedListener(\n  response => {\n    // Update the value\n    globalInitialNotificationResponse = response;\n  }\n);\n\nfunction dispatchSetInitialResponseAndClear() {\n  // process.nextTick/requestAnimationFrame-like\n  setTimeout(() => {\n    // If there was an initial notification response,\n    // it is already defined, otherwise\n    // let's define it as null.\n    globalInitialNotificationResponse = globalInitialNotificationResponse ?? null;\n    // We can now clear the global subscription\n    if (initialNotificationResponseSubscription) {\n      initialNotificationResponseSubscription.remove();\n      initialNotificationResponseSubscription = null;\n    }\n    // We don't need to ever run this function again.\n    AppState.removeEventListener('change', dispatchSetInitialResponseAndClear);\n  }, 0);\n}\n\nAppState.addEventListener('change', dispatchSetInitialResponseAndClear);\n\n/**\n * Returns an initial notification response if the app\n * was opened as a result of tapping on a notification,\n * null if the app doesn't seem to be opened as a result\n * of tapping on a notification, or undefined until we are sure\n * of which to return.\n */\nexport default function useInitialNotificationResponse() {\n  const [initialNotificationResponse, setInitialNotificationResponse] = useState<\n    NotificationResponse | null | undefined\n  >(globalInitialNotificationResponse);\n\n  useEffect(() => {\n    // process.nextTick & requestAnimationFrame-like\n    // Executes after dispatchSetInitialResponseAndClear's inner callback\n    const timeoutId = setTimeout(() => {\n      // Ensure the value is not undefined (if by this time\n      // it's still undefined there was no \"initial notification response\").\n      setInitialNotificationResponse(\n        currentResponse => currentResponse ?? globalInitialNotificationResponse ?? null\n      );\n    }, 0);\n\n    return () => {\n      clearTimeout(timeoutId);\n    };\n  }, []);\n\n  return initialNotificationResponse;\n}\n"]}